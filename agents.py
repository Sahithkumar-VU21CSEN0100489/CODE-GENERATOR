# agents.py
# This file contains the logic for each individual AI agent.

import os
from dotenv import load_dotenv
import google.generativeai as genai
import tempfile
import subprocess
import base64
from PIL import Image
from pyvirtualdisplay import Display

# --- Configuration ---
load_dotenv()
API_KEY = os.environ.get("GEMINI_API_KEY")

try:
    genai.configure(api_key=API_KEY)
except Exception as e:
    print(f"Error configuring Gemini API: {e}")
    # Fallback for environments where the key might be set via environment variables
    if not API_KEY and 'GEMINI_API_KEY' in os.environ:
        genai.configure(api_key=os.environ['GEMINI_API_KEY'])


# --- Agent Functions ---

def run_prompt_engineer(user_task: str) -> str:
    """
    Takes a user's task and generates a detailed, actionable prompt for the developer agent.
    
    Args:
        user_task: The high-level task description from the user.
        
    Returns:
        A detailed prompt string.
    """
    print("\n🤖 Prompt Engineer Agent is running...")
    
    system_prompt = f"""
You are an expert Prompt Engineer AI. Your job is to take the following user's request and convert it into a detailed, unambiguous, and actionable prompt for a developer AI. The prompt must be directly and specifically about the user's request, and should not ignore, generalize, or change the intent of the user's input.

User Request: "{user_task}"

Generate a detailed prompt for a developer to implement exactly what the user asked for. Do not add unrelated information. Do not write any code yourself. If the user request is ambiguous, ask for clarification in the prompt.
"""
    
    try:
        model = genai.GenerativeModel('gemini-2.5-pro')
        response = model.generate_content(system_prompt)
        print("✅ Prompt Engineer finished.")
        return response.text
    except Exception as e:
        print(f"Error during Prompt Engineer execution: {e}")
        return f"Error: Could not generate prompt. Details: {e}"


def run_developer(engineered_prompt: str) -> str:
    """
    Takes a detailed prompt and generates the corresponding code and requirements.txt.
    Args:
        engineered_prompt: The detailed specification from the Prompt Engineer.
    Returns:
        A string containing all generated files in a parseable format.
    """
    print("\n💻 Developer Agent is running...")

    system_prompt = f"""
You are an expert Developer AI. Your job is to write a complete, runnable project based on the provided specification.

Requirements:
- If the user's request is for a user interface (UI) and does not specify a desktop GUI framework, generate a web UI using HTML, CSS, and JavaScript by default.
- Output as many files as needed for the user's request (e.g., index.html, style.css, script.js, requirements.txt, .env, README.md, etc.).
- For each file, use the following format:
  ---file:<filename>---
  <file content>
- Do not include explanations, markdown formatting, or extra text—only the files in the format above.
- If the task is ambiguous, make reasonable assumptions.

Specification:
---
{engineered_prompt}
---

Generate all required files now.
"""

    try:
        model = genai.GenerativeModel('gemini-2.5-pro')
        response = model.generate_content(system_prompt)
        print("✅ Developer finished.")
        return response.text
    except Exception as e:
        print(f"Error during Developer execution: {e}")
        return f"# Error: Could not generate code. Details: {e}"


def run_code_reviewer(code_to_review: str) -> str:
    """
    Takes generated code and provides a structured, actionable quality assurance review.
    Args:
        code_to_review: The code generated by the Developer agent.
    Returns:
        A string containing the structured code review.
    """
    print("\n🔍 Code Reviewer Agent is running...")

    system_prompt = f"""
You are an expert Code Reviewer AI. Analyze the provided code and give a structured, actionable review.

Your review must include:
- STATUS: (Approved / Needs Changes)
- Strengths: (What is good about the code)
- Issues/Concerns: (List and explain any bugs, style issues, security risks, or unclear logic. Rate each by severity: Critical, Major, Minor, Info)
- Suggestions for Improvement: (How to fix or improve the code)
- Test Suggestions: (Optional: suggest tests to verify the code)

Code to review:
---
{code_to_review}
---

Provide your review in the above structure.
"""

    try:
        model = genai.GenerativeModel('gemini-2.5-pro')
        response = model.generate_content(system_prompt)
        print("✅ Code Reviewer finished.")
        return response.text
    except Exception as e:
        print(f"Error during Code Reviewer execution: {e}")
        return f"Error: Could not review code. Details: {e}"


def run_preview_agent(code: str) -> bytes:
    """
    Runs Tkinter Python code in a virtual display and returns a screenshot as bytes.
    Returns None if preview fails.
    """
    try:
        with tempfile.TemporaryDirectory() as tmpdir:
            code_path = f'{tmpdir}/preview.py'
            img_path = f'{tmpdir}/preview.png'
            # Wrap code to save a screenshot after mainloop
            wrapped_code = f"""
import sys
import threading
from PIL import ImageGrab

def take_screenshot():
    import time
    time.sleep(1)
    img = ImageGrab.grab()
    img.save(r'{img_path}')
    sys.exit(0)

threading.Thread(target=take_screenshot, daemon=True).start()
""" + code
            with open(code_path, 'w', encoding='utf-8') as f:
                f.write(wrapped_code)
            with Display():
                subprocess.run(['python', code_path], timeout=10)
            with open(img_path, 'rb') as imgf:
                img_bytes = imgf.read()
            return img_bytes
    except Exception as e:
        print(f"Preview agent failed: {e}")
        return None


def run_project_preview(files):
    """
    Given a list of files (dicts with 'filename' and 'content'), writes them to a temp dir and previews the project.
    Returns a dict: {'type': 'html', 'content': ...} or {'type': 'image', 'content': ...} or {'type': 'error', 'content': ...}
    """
    import shutil
    try:
        with tempfile.TemporaryDirectory() as tmpdir:
            # Write all files
            for file in files:
                file_path = os.path.join(tmpdir, file['filename'])
                os.makedirs(os.path.dirname(file_path), exist_ok=True)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(file['content'])
            # Detect project type
            html_path = os.path.join(tmpdir, 'index.html')
            tkinter_py = None
            for file in files:
                if file['filename'].endswith('.py') and ('import tkinter' in file['content'] or 'from tkinter' in file['content']):
                    tkinter_py = os.path.join(tmpdir, file['filename'])
            if os.path.exists(html_path):
                # Web project: return HTML content
                with open(html_path, 'r', encoding='utf-8') as f:
                    html_content = f.read()
                return {'type': 'html', 'content': html_content}
            elif tkinter_py:
                # Tkinter project: run and return screenshot
                img_path = os.path.join(tmpdir, 'preview.png')
                wrapped_code = f"""
import sys
import threading
from PIL import ImageGrab

def take_screenshot():
    import time
    time.sleep(1)
    img = ImageGrab.grab()
    img.save(r'{img_path}')
    sys.exit(0)

threading.Thread(target=take_screenshot, daemon=True).start()
"""
                # Prepend screenshot code to main tkinter file
                with open(tkinter_py, 'r', encoding='utf-8') as f:
                    orig_code = f.read()
                with open(tkinter_py, 'w', encoding='utf-8') as f:
                    f.write(wrapped_code + orig_code)
                with Display():
                    subprocess.run(['python', tkinter_py], timeout=10)
                with open(img_path, 'rb') as imgf:
                    img_bytes = imgf.read()
                return {'type': 'image', 'content': img_bytes}
            else:
                return {'type': 'error', 'content': 'No previewable entry point (index.html or Tkinter .py) found.'}
    except Exception as e:
        print(f"Project preview failed: {e}")
        return {'type': 'error', 'content': f'Preview failed: {e}'}
